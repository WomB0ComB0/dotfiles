# -*- shell -*-
# ~/.installrc: Auto-install missing commands for .bashrc
# Source this file in your .bashrc to automatically install missing dependencies

# Skip if not interactive or if INSTALLRC_DISABLE is set
[[ $- != *i* ]] && return
[[ -n "${INSTALLRC_DISABLE:-}" ]] && return

# Only run once per session
[[ -n "${INSTALLRC_RAN:-}" ]] && return
export INSTALLRC_RAN=1

# Quiet mode by default, set INSTALLRC_VERBOSE=1 to see output
INSTALLRC_VERBOSE="${INSTALLRC_VERBOSE:-0}"

# Colors for output (only if verbose)
if [[ "$INSTALLRC_VERBOSE" == "1" ]]; then
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    BLUE='\033[0;34m'
    NC='\033[0m'
else
    RED='' GREEN='' YELLOW='' BLUE='' NC=''
fi

# Logging functions
log_info() {
    [[ "$INSTALLRC_VERBOSE" == "1" ]] && echo -e "${BLUE}[INSTALLRC]${NC} $1" >&2
}

log_success() {
    [[ "$INSTALLRC_VERBOSE" == "1" ]] && echo -e "${GREEN}[INSTALLRC]${NC} $1" >&2
}

log_warning() {
    [[ "$INSTALLRC_VERBOSE" == "1" ]] && echo -e "${YELLOW}[INSTALLRC]${NC} $1" >&2
}

log_error() {
    [[ "$INSTALLRC_VERBOSE" == "1" ]] && echo -e "${RED}[INSTALLRC]${NC} $1" >&2
}

# Check if command exists
command_exists() {
    command -v "$1" &> /dev/null
}

# Detect package manager
detect_package_manager() {
    if command_exists pacman; then
        echo "pacman"
    elif command_exists apt; then
        echo "apt"
    elif command_exists dnf; then
        echo "dnf"
    elif command_exists yum; then
        echo "yum"
    elif command_exists zypper; then
        echo "zypper"
    elif command_exists brew; then
        echo "brew"
    else
        echo "unknown"
    fi
}

# Install package silently
install_package_silent() {
    local package="$1"
    local pm="$2"
    
    case "$pm" in
        "pacman")
            sudo pacman -S --noconfirm "$package" &>/dev/null
            ;;
        "apt")
            sudo apt update &>/dev/null && sudo apt install -y "$package" &>/dev/null
            ;;
        "dnf")
            sudo dnf install -y "$package" &>/dev/null
            ;;
        "yum")
            sudo yum install -y "$package" &>/dev/null
            ;;
        "zypper")
            sudo zypper install -y "$package" &>/dev/null
            ;;
        "brew")
            brew install "$package" &>/dev/null
            ;;
        *)
            return 1
            ;;
    esac
}

# Background installation function
install_missing_background() {
    local pm
    pm=$(detect_package_manager)
    
    [[ "$pm" == "unknown" ]] && return 1
    
    # Critical commands that should be available immediately
    local critical_commands=(
        "git" "curl" "wget" "tree" "unzip" "nano" "make" "gcc"
    )
    
    # Define complete package mappings
    declare -A package_map=(
        # Core utilities
        ["git"]="git"
        ["curl"]="curl"
        ["wget"]="wget"
        ["tree"]="tree"
        ["unzip"]="unzip"
        ["tar"]="tar"
        ["gzip"]="gzip"
        ["7z"]="p7zip-full:p7zip:p7zip"
        ["unrar"]="unrar"
        ["xclip"]="xclip"
        ["wl-paste"]="wl-clipboard"
        ["notify-send"]="libnotify-utils:libnotify:libnotify"
        ["neofetch"]="neofetch"
        ["nano"]="nano"
        
        # Network tools
        ["netstat"]="net-tools"
        ["ss"]="iproute2"
        
        # Development tools
        ["make"]="make"
        ["gcc"]="gcc"
        ["g++"]="gcc:g++:gcc-c++"
        ["python3"]="python3:python:python3"
        ["pip3"]="python3-pip:python-pip:python3-pip"
        ["node"]="nodejs"
        ["npm"]="npm"
        ["ruby"]="ruby"
        ["gem"]="rubygems:ruby:ruby"
        ["php"]="php"
        ["go"]="go:golang:go"
        ["swift"]="swift-lang:swift:swift"
        ["java"]="openjdk-11-jdk:java-11-openjdk:java-11-openjdk"
        ["javac"]="openjdk-11-jdk:java-11-openjdk-devel:java-11-openjdk-devel"
        
        # Build tools
        ["cmake"]="cmake"
        ["autoconf"]="autoconf"
        ["automake"]="automake"
        ["pkg-config"]="pkg-config:pkgconfig:pkgconf"
        
        # Text processing
        ["jq"]="jq"
        ["sed"]="sed"
        ["awk"]="gawk:awk:gawk"
        ["grep"]="grep"
        
        # System monitoring
        ["htop"]="htop"
        ["top"]="procps:procps-ng:procps-ng"
        ["ps"]="procps:procps-ng:procps-ng"
        ["free"]="procps:procps-ng:procps-ng"
        ["df"]="coreutils"
        ["du"]="coreutils"
        
        # Compression tools
        ["zip"]="zip"
        ["bzip2"]="bzip2"
        ["xz"]="xz-utils:xz:xz"
    )
    
    # Install critical commands first
    for cmd in "${critical_commands[@]}"; do
        if ! command_exists "$cmd" && [[ -n "${package_map[$cmd]:-}" ]]; then
            log_info "Installing critical command: $cmd"
            local packages="${package_map[$cmd]}"
            local package
            
            # Get correct package name for package manager
            case "$pm" in
                "pacman")
                    package=$(echo "$packages" | cut -d: -f1)
                    ;;
                "apt")
                    package=$(echo "$packages" | cut -d: -f2)
                    [[ -z "$package" ]] && package=$(echo "$packages" | cut -d: -f1)
                    ;;
                "dnf"|"yum")
                    package=$(echo "$packages" | cut -d: -f3)
                    [[ -z "$package" ]] && package=$(echo "$packages" | cut -d: -f1)
                    ;;
                *)
                    package=$(echo "$packages" | cut -d: -f1)
                    ;;
            esac
            
            if install_package_silent "$package" "$pm"; then
                log_success "Installed $package"
            fi
        fi
    done
    
    # Install other commands in background (non-blocking)
    {
        for cmd in "${!package_map[@]}"; do
            # Skip if already processed in critical commands
            local is_critical=false
            for critical_cmd in "${critical_commands[@]}"; do
                [[ "$cmd" == "$critical_cmd" ]] && { is_critical=true; break; }
            done
            [[ "$is_critical" == true ]] && continue
            
            if ! command_exists "$cmd"; then
                log_info "Background installing: $cmd"
                local packages="${package_map[$cmd]}"
                local package
                
                # Get correct package name for package manager
                case "$pm" in
                    "pacman")
                        package=$(echo "$packages" | cut -d: -f1)
                        ;;
                    "apt")
                        package=$(echo "$packages" | cut -d: -f2)
                        [[ -z "$package" ]] && package=$(echo "$packages" | cut -d: -f1)
                        ;;
                    "dnf"|"yum")
                        package=$(echo "$packages" | cut -d: -f3)
                        [[ -z "$package" ]] && package=$(echo "$packages" | cut -d: -f1)
                        ;;
                    *)
                        package=$(echo "$packages" | cut -d: -f1)
                        ;;
                esac
                
                if install_package_silent "$package" "$pm"; then
                    log_success "Background installed $package"
                fi
            fi
        done
        
        # Install version managers if not present
        install_version_managers_background
        create_directories_silent
    } &
    
    # Store background job PID
    export INSTALLRC_BG_PID=$!
}

# Silent version manager installation
install_version_managers_background() {
    # NVM
    if [[ ! -d "$HOME/.nvm" ]] && command_exists curl; then
        log_info "Installing NVM..."
        curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh 2>/dev/null | bash &>/dev/null
        log_success "NVM installed"
    fi
    
    # PYENV
    if [[ ! -d "$HOME/.pyenv" ]] && command_exists curl; then
        log_info "Installing pyenv..."
        curl https://pyenv.run 2>/dev/null | bash &>/dev/null
        log_success "pyenv installed"
    fi
    
    # Deno
    if ! command_exists deno && command_exists curl; then
        log_info "Installing Deno..."
        curl -fsSL https://deno.land/install.sh 2>/dev/null | sh &>/dev/null
        log_success "Deno installed"
    fi
    
    # Bun
    if ! command_exists bun && command_exists curl; then
        log_info "Installing Bun..."
        curl -fsSL https://bun.sh/install 2>/dev/null | bash &>/dev/null
        log_success "Bun installed"
    fi
    
    # PNPM
    if ! command_exists pnpm && command_exists curl; then
        log_info "Installing PNPM..."
        curl -fsSL https://get.pnpm.io/install.sh 2>/dev/null | sh - &>/dev/null
        log_success "PNPM installed"
    fi
}

# Create directories silently
create_directories_silent() {
    local dirs=(
        "$HOME/.local/bin"
        "$HOME/github"
        "$HOME/gems"
    )
    
    for dir in "${dirs[@]}"; do
        if [[ ! -d "$dir" ]]; then
            mkdir -p "$dir" 2>/dev/null
            log_success "Created directory: $dir"
        fi
    done
}

# Main execution - run automatically when sourced
# Only run if we have sudo access (check if we're not already root and sudo exists)
if [[ $EUID -ne 0 ]] && command_exists sudo && sudo -n true 2>/dev/null; then
    install_missing_background
elif [[ $EUID -eq 0 ]]; then
    # Running as root, modify install functions to not use sudo
    install_missing_background
else
    # No sudo access, only install user-level tools
    log_info "No sudo access detected, installing user-level tools only"
    {
        install_version_managers_background
        create_directories_silent
    } &
    export INSTALLRC_BG_PID=$!
fi

# Add function to check background installation status
installrc_status() {
    if [[ -n "${INSTALLRC_BG_PID:-}" ]]; then
        if kill -0 "$INSTALLRC_BG_PID" 2>/dev/null; then
            echo "Background installation still running (PID: $INSTALLRC_BG_PID)"
            echo "Use 'installrc_wait' to wait for completion"
        else
            echo "Background installation completed"
            unset INSTALLRC_BG_PID
        fi
    else
        echo "No background installation running"
    fi
}

# Add function to wait for background installation
installrc_wait() {
    if [[ -n "${INSTALLRC_BG_PID:-}" ]]; then
        echo "Waiting for background installation to complete..."
        wait "$INSTALLRC_BG_PID" 2>/dev/null
        echo "Background installation completed"
        unset INSTALLRC_BG_PID
    else
        echo "No background installation running"
    fi
}

# Add function to manually trigger installation with verbose output
installrc_install() {
    INSTALLRC_VERBOSE=1 install_missing_background
}

# Clean up any stale background processes on exit
trap 'kill ${INSTALLRC_BG_PID} 2>/dev/null || true' EXIT

# Log completion (only if verbose)
log_info "Auto-installation initialized"
